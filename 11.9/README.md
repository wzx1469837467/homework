/面向对象编程/

JavaScript中的对象是什么？

在JavaScript中，所谓的对象，就是键值对的集合

属性和方法是什么？

比如要描述一个人，这个人有name,age,gender,体现在代码中：

{ name:"张三", age:18, gender:"Male" }

面向过程关注的实现功能的步骤，是如何把功能拆解后一步步的实现
面向对象则是关注的实现功能的一系列的对象

/面向对象的特性/

封装性

对象是将数据与功能组合到一起, 即封装

js 对象就是 键值对的集合
键值如果是数据( 基本数据, 复合数据, 空数据 ), 就称为属性
如果键值是函数, 那么就称为方法
对象就是将属性与方法封装起来
方法是将过程封装起来

继承性

所谓继承就是自己没有, 别人有,拿过来为自己所用, 并成为自己的东西

传统继承基于模板

子类可以使用从父类继承的属性和方法。

class Person {
 string name;
 int age;
}

class Student : Person {
}
var stu = new Student();
stu.name

多态性（基于强类型）只做了解

把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化



/*构造函数*/

在JavaScript中，构造函数是给对象添加属性，初始化属性用的

对象的创建过程

var p = new Person();

首先使用new关键字创建对象，类似于使用{},这个时候创建出来的对象是一个"没有任何成员"的对象。这里需要注意两点：
使用new关键字创建的对象，对象的类型就是创建这个对象使用的构造函数的函数名
使用{}创建对象，对象的类型一定是Object，相当于使用了new Object()
使用构造函数为其初始化成员
在构造函数调用开始的时候，有一个赋值操作，也就是让this = 刚创建出来的对象
在构造函数中，this就代表刚创建出来的对象
在构造函数中，利用对象的动态特性，为对象添加成员

/*原型*/

传统构造函数存在的问题
function sayHello(){
    console.log("你好");
}
function Person(name, age){
    this.name = name;
    this.age = age;
    this.sayHi = function(){
        console.log("你好");
    }
}

var p = new Person("张三", 18);
var p1 = new Person("李四", 19);
console.log(p.sayHi == p1.sayHi);

由于每个对象都是由new Person创建出来的，因此每创建一个对象，函数sayHi都会被重新创建一次，这个时候，每个对象都拥有一个独立的，但是功能完全相同的方法。

功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。

使用原型解决构造函数问题
function Person(name, age){
    this.name = name;
    this.age = age;
}

Person.prototype.sayHi = function(){
    console.log("你好");
};

var p = new Person("张三", 18);
var p1 = new Person("李四", 19);

console.log(p.sayHi == p1.sayHi); 
所有对象共享神秘对象(构造函数.prototype)内的属性和方法。我们只需要将需要共享的东西，也就是重复占用内存的东西，全部都放到 神秘对象(构造函数.prototype)中，那么所有对象就都可以使用，并且内存里面也只有一份了

神秘对象就是构造函数的 "原型属性"
简称原型 (构造函数的原型)

/原型继承/
构造函数创建的对象 继承自 构造函数的原型属性
构造函数创建的对象 继承自 该对象的原型对象
原型中的成员, 可以直接被实例对象所使用
实例对象直接 "含有" 原型中的成员
因此实例对象 继承自 原型
这样的继承就是 "原型继承"


/对象的__proto__属性/

1.标识符命名规则

区分大小写,Name和name是两个不同的变量

标识符可以以下划线_,美元符$或者字母开头，但是不能是数字

标识符可以由下划线_，美元符$，字母，数字组成

2.__proto__属性的用途

可以用来访问原型

在实际开发中除非有特殊的需求，不要轻易的使用实例对象的__proto__属性去修改原型的成员，

在调试过程中，可以轻易的查看原型的成员

tips:

早期如何通过实例对象访问原型？

可以使用实例对象访问构造函数属性constuctor


var p = new Person();
p.constructor.prototype;


/*原型链结构*/

凡是对象就有原型, 原型又是对象, 因此凡是给定义一个对象, 那么就可以找到他的原型, 原型还有原型. 那么如此下去, 就构成一个对象的序列. 称该结构为原型链.


function Person() {
}

var p = new Person();
// p 具有默认的原型链

默认的原型链结构就是:

当前对象 -> 构造函数.prototype -> Object.prototype -> null

在实现继承的时候, 有时会利用替换原型链结构的方式实现原型继承, 那么原型链结构就会发生改变


/*Object.prototype介绍*/

Object.prototype常用成员

成员	                                   描述
Object.prototype.__proto__	指向当对象被实例化的时候，用作原型的对象。
Object.prototype.hasOwnProperty()	返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。
Object.prototype.isPrototypeOf()	返回一个布尔值，表示指定的对象是否在本对象的原型链中。
Object.prototype.toString()	返回对象的字符串表示。
Object.prototype.valueOf()	返回指定对象的原始值。


/*函数的构造函数Function*/

在 js 中 使用Function可以实例化函数对象。也就是说在 js 中函数与普通对象一样, 也是一个对象类型. 函数是 js 中的一等公民.

函数是对象, 就可以使用对象的动态特性

函数是对象, 就有构造函数创建函数

函数是函数, 可以创建其他对象

函数是唯一可以限定变量作用域的结构

Function函数所有的参数全都是字符串
Function函数的作用就是将所有的参数组合起来，变成一个函数
1.如果只传一个参数，那么这个函数必然是函数体
2.如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数
3.如果不传参数，表示创建一个空函数


/*arguments对象*/

在每一个函数调用的过程中, 函数代码体内有一个默认的对象arguments, 它存储着实际传入的所有参数。

arguments是一个伪数组对象. 它表示在函数调用的过程中传入的所有参数的集合。在函数调用过程中不规定参数的个数与类型, 可以使得函数调用变得非常灵活性。

JavaScript中的函数并没有规定必须如何传参：

定义函数的时候不写参数, 一样可以调用时传递参数
定义的时候写了参数, 调用的时候可以不传参
定义的时候写了一个参数, 调用的时候可以随意的传递多个而参数
在代码设计中, 如果需要函数带有任意个参数的时候, 一般就不带任何参数, 所有的参数利用arguments对象来获取. 一般的函数定义语法, 可以写成:


function foo ( /* ... */ ) {
}
