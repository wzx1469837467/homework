# 作用域 #

域，表示的是一个范围，作用域，就是作用范围。

作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用

# 块级作用域 #

JavaScript中没有块级作用域

在JavaScript中没有块级作用域，使用{}标记出来的代码块中声明的变量num，是可以被{}外面访问到的。

在其他的编程语言中，有块级作用域，那么{}中声明的变量num，是不能在代码块外部访问的，会报错。

# 词法作用域 #

词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是词法作用域.

在 js 中词法作用域规则:

函数允许访问函数外的数据.

整个代码结构中只有函数可以限定作用域.

作用域规则首先使用提升规则分析

如果当前作用规则中有名字了, 就不考虑外面的名字

# 作用域链 #


只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。

凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。

将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。

# 变量的访问规则 #

首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用

如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找.

如果还没有再次往上刚找... 直到全局链( 0 级 ), 还没有就是 is not defined

同级的链不可混合查找


# 闭包 #

在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包.

闭包要解决的问题

闭包内的数据不允许外界访问
要解决的问题就是间接访问该数据

# 函数的四种调用模式 #

+ 函数模式

特征:就是一个简单的函数调用，函数名前面没有任何的引导内容

function foo(){}
var func = function(){}

foo();
func();
(function(){})();

this在函数模式中的含义： this在函数中表示全局对象，在浏览器中是window对象
+ 方法模式

特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法.

function f() {
    this.method = function () {};
}

var o = {
    method: function () {}
}

this在方法模式调用中的含义:表示函数所依附的这个对象

+ 构造器调用模式

由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别.

特征:使用 new 关键字, 来引导构造函数.


+ 创建对象的模式

+ 工厂方法
如果函数创建对象并返回, 就称该函数为工厂函数
    function createPerson( name, age, gender ) {
    var o = {};
    o.name = name;
    o.age = age;
    o.gender = gender;
    return o;

+ 构造方法
    function Person(name, age, gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
}

    var p = new Person("zhangsan", 19, "男");

+ 寄生式创建对象

function Person(name, age, gender){
    var o = {};
    o.name = name;
    o.age = age;
    o.gender = gender;
    return o;
}

var p = new Person("Jack", 18, "male");

# 上下文调用模式 #

语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象

语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象

在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定



使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示
function foo( num ) {

 console.log( num );

}

foo.apply( null, [ 123 ] );

foo( 123 );